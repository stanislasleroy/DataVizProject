<html>

<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.7/leaflet.css" />
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="https://d3js.org/d3-queue.v3.min.js"></script>
    <script src="http://cdn.leafletjs.com/leaflet-0.7/leaflet.js">
    </script>
    <style>
        body {
            margin: 0;
            position: fixed;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
        }
        
        #map {
            width: 100%;
            height: 100%;
        }
        
        .hidden {
            display: none;
        }
        
        div.tooltip {
            color: #222;
            background-color: #fff;
            padding: .5em;
            text-shadow: #f5f5f5 0 1px 0;
            border-radius: 2px;
            opacity: 0.9;
            position: absolute;
        }
        
        .hiddenLine {
            display: none;
        }
    </style>
</head>

<body>
    <div>
        <input id="slider" type="range" value="1" min="1" max="100" step="1" />
        <span id="week">heure</span>
    </div>
    <div id="map">

        <!--<div id="map" style="width: 600px; height: 400px"></div>-->

        <script>
            //var map = L.map('map').setView([-41.2858, 174.7868], 13);
            /*
                      mapLink =
                          '<a href="http://openstreetmap.org">OpenStreetMap</a>';
                      L.tileLayer(
                          'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                          attribution: '&copy; ' + mapLink + ' Contributors',
                          maxZoom: 18,
                          }).addTo(map);
                          */
            //var map = new L.Map("map", {center: [45.750000, 4.850000], zoom: 13})
            // .addLayer(new L.TileLayer("http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"));

            var initialZoom = 14;

            // Temps de trajet théorique des différents lignes (ms)
            var durationA = 1260000; // 21 minutes
            var durationB = 1020000; // 17 minutes
            var durationC = 540000; // 9 minutes // TEST
            var durationD = 1500000; // 25 minutes TEST
            var duration = 10000;

            // var divider  = 1000;
            var divider = 100;

            // Distance pour prendre en compte les stations Vélov voisine
            // des stations de métro
            var distanceToStation = 200;

            var details_line = {};
            var selectedLine = "";

            var map = L.map('map').setView([45.750000, 4.850000], initialZoom);

            L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token={accessToken}', {
                attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="http://mapbox.com">Mapbox</a>',
                maxZoom: 18,
                id: 'stanislasleroy.293gad2b',
                accessToken: 'pk.eyJ1Ijoic3RhbmlzbGFzbGVyb3kiLCJhIjoiY2l3N29ieTFhMDAwbzJ6bzYydmM0cjM4cyJ9.a9t7av6dljaj5TN_FA4XvQ'
            }).addTo(map);

            map.on('click', function(d) {
                // console.log(d);
                var e = d.originalEvent.path[0];
                // console.log(e);

                if (!d3.select(e).attr("class")) {
                    // console.log(d3.select(e).attr("class"));
                    selectedLine = "";
                    d3.selectAll('.train').each(function(d, i) {
                        d3.select(this).classed("hiddenLine", false);
                    });
                }

                // d3.select(this).style("stroke-width", 8);
                // selectedLine = d.properties.code_titan.substring(0, 3);
            })

            var transform = d3.geo.transform({
                point: projectPoint
            });
            var path = d3.geo.path().projection(transform);

            var svg = d3.select(map.getPanes().overlayPane).append("svg");

            var g = svg.append("g").attr("class", "leaflet-zoom-hide");

            var tooltip = d3.select('body').append('div')
                .attr('class', 'hidden tooltip');

            map.on("viewreset", reset);



            // d3.queue()
            //   .defer(d3.json, "tram.json")
            //   .await(displaySecondaryLine);
            //
            // d3.queue()
            //   .defer(d3.json, "bus.json")
            //   .await(displaySecondaryLine);

            d3.queue()
                .defer(d3.json, "point_arret.json")
                .defer(d3.json, "ligne_metro.json")
                .defer(d3.json, "stations.json")
                .await(displayPrimaryLine);


            /*
             * Création des lignes secondaires : tram et bus
             */
            function displaySecondaryLine(error, lines) {

                var feature = g.selectAll("pathTram")
                    .data(lines.features)
                    .enter().append("path")
                    .style({
                        'fill': '#B10000',
                        'fill-opacity': 0.0
                    })
                    .style({
                        'stroke-width': 1,
                        'stroke': 'red',
                        'stroke-linejoin': 'round',
                        'stroke-linecap': 'round'
                    })
                    .style("stroke", function(d) {
                        var array = d.properties.couleur.split(" ");
                        var color = (d3.rgb(array[0], array[1], array[2])).toString();
                        return color;
                    });

                reset(path, lines, feature);
            }


            /*
             * Affichage des stations Vélo'v
             */
            // function displayBikeStation(error, stations) {
            //
            //   var feature = g.selectAll("pathVelov")
            //       .data(stations.features)
            //       .enter().append("path")
            //       .classed("stationsVelo", true)
            //       .style("stroke", "black")
            //       .style("fill", function(d) { return d.properties.stationbonus === "Oui" ? "#FFBF00" : "#d3d3d3";})
            //       .on('mousemove', function(d) {
            //         var mouse = d3.mouse(svg.node()).map(function(d) {
            //           return parseInt(d);
            //         });
            //           //console.log(d);
            //            tooltip.classed('hidden', false)
            //             .attr('style', 'left:' + (mouse[0]) + 'px; top:' + (mouse[1]) + 'px')
            //             .html(d.properties.nom + "<br>Id station : " + d.properties.idstation + "<br>Nb de bornes : " + d.properties.nbbornettes + "<br>Station bonus : " + d.properties.stationbonus);
            //             d3.select(this).style("stroke", "red");
            //             d3.select(this).style("stroke-width", "15");
            //       })
            //       .on('mouseout', function() {
            //         tooltip.classed('hidden', true);
            //         d3.select(this).style("stroke", "black");
            //         d3.select(this).style("stroke-width", "2");
            //       });
            //
            //   reset(path, stations, feature);
            // }


            /*
             * Affichage des lignes de métro et des stations
             */
            function displayPrimaryLine(error, stationsMetro, lines, stationsVelo) {

                /*
                 * Affichage des stations Vélo'v
                 */
                var feature = g.selectAll("pathVelov")
                    .data(stationsVelo.features)
                    .enter().append("path")
                    .classed("stationsVelo", true)
                    .style("stroke", "black")
                    .style("fill", function(d) {
                        return d.properties.stationbonus === "Oui" ? "#FFBF00" : "#d3d3d3";
                    })
                    .on('mouseover', function(d) {
                        var mouse = d3.mouse(svg.node()).map(function(d) {
                            return parseInt(d);
                        });
                        tooltip.classed('hidden', false)
                            .attr('style', 'left:' + (mouse[0]) + 'px; top:' + (mouse[1]) + 'px')
                            .html(d.properties.nom + "<br>Id station : " + d.properties.idstation + "<br>Nb de bornes : " + d.properties.nbbornettes + "<br>Station bonus : " + d.properties.stationbonus);
                        d3.select(this).style("stroke", "red");
                        // d3.select(this).style("stroke-width", "10");
                    })
                    .on('mouseout', function() {
                        tooltip.classed('hidden', true);
                        d3.select(this).style("stroke", "black");
                        // d3.select(this).style("stroke-width", "2");
                    });

                reset(path, stationsVelo, feature);



                // On ajoute les codes Titan des lignes de métro pour pouvoir récupérer les points d'arrêts des lignes
                for (var i in lines.features) {
                    var id = lines.features[i].properties.code_titan;
                    id = id.substring(0, 3);
                    details_line[id] = {};
                    details_line[id].id = id;
                    details_line[id].color = lines.features[i].properties.couleur;
                }

                // On ajoute les codes Titan des lignes de métro pour pouvoir récupérer les points d'arrêts des lignes
                for (var i in stationsMetro.features) {

                    var id = stationsMetro.features[i].properties.desserte.substring(0, 3);

                    if (details_line[id]) {

                        if (!details_line[id].stops)
                            details_line[id].stops = [];

                        var stop = {};
                        stop.geo = {};
                        stop.geo.x = stationsMetro.features[i].geometry.coordinates[0];
                        stop.geo.y = stationsMetro.features[i].geometry.coordinates[1];
                        details_line[id].stops.push(stop);
                    }
                }

                /*
                 * Affichage des stations Métro
                 */
                // console.log(JSON.stringify(stationsMetro.features[0]));
                // console.log(stationsMetro.features[0]);
                // console.log(stationsMetro.features.length);

                var feature = g.selectAll("pathStationsMetro")
                    .data(stationsMetro.features)
                    .enter().append("path")
                    .filter(function(d) { // Filtrer les données pour ne garder que les arrêts des lignes de métro
                        var id = d.properties.desserte.substring(0, 3);
                        if (details_line[id])
                            return true;
                        else
                            return false;
                    })
                    .classed("stationsMetro", true)
                    .attr("id", function(d) {
                        return d.properties.id;
                    })
                    .style({
                        'stroke-width': 4,
                        'stroke-linejoin': 'round',
                        'stroke-linecap': 'round'
                    })
                    .style("stroke", function(d) {
                        var id = d.properties.desserte.substring(0, 3);
                        var array = details_line[id].color.split(" ");
                        var color = (d3.rgb(array[0], array[1], array[2])).toString();
                        return color;
                    })
                    .style("fill", function(d) {
                        var id = d.properties.desserte.substring(0, 3);
                        var array = details_line[id].color.split(" ");
                        var color = (d3.rgb(array[0], array[1], array[2])).toString();
                        return color;
                    });

                reset(path, stationsMetro, feature);


                /*
                 * Affichage des lignes de Métro
                 */
                var feature = g.selectAll("pathMetroLine")
                    .data(lines.features)
                    .enter().append("path")
                    .classed("lineMetro", true)
                    .attr("sens", function(d) {
                        return d.properties.sens;
                    })
                    .attr("ligne", function(d) {
                        return d.properties.ligne;
                    })
                    .attr("code_titan", function(d) {
                        return d.properties.code_titan.substring(0, 3);
                    })
                    .style({
                        'fill': 'none'
                    })
                    .style({
                        'stroke-width': 4,
                        'stroke-linejoin': 'round',
                        'stroke-linecap': 'round'
                    })
                    .style("stroke", function(d) {
                        var array = d.properties.couleur.split(" ");
                        var color = (d3.rgb(array[0], array[1], array[2])).toString();
                        return color;
                    })
                    .on('mousemove', function(d) {
                        d3.select(this).style("stroke-width", 8);
                    })
                    .on('click', function(d) {
                        d3.select(this).style("stroke-width", 8);
                        selectedLine = d.properties.code_titan.substring(0, 3);
                        //  console.log(d3.selectAll('.train').filter(".t" + selectedLine));

                        d3.selectAll('.train').each(function(d, i) {
                            d3.select(this).classed("hiddenLine", true);
                        });

                        d3.selectAll('.train').filter(".t" + selectedLine).each(function(d, i) {
                            d3.select(this).classed("hiddenLine", false);
                        });
                    })
                    .on('mouseout', function() {
                        d3.select(this).style("stroke-width", 4);
                    });

                reset(path, lines, feature);



                /*
                 * Animation des rames de métro
                 */
                var nodes = d3.selectAll('.lineMetro')[0];

                nodes.forEach(function(data, i) {

                    (function repeat() {

                        // if(selectedLine == "") {
                        // console.log(selectedLine);

                        // if(d3.select(data).attr("code_titan") == selectedLine){

                        var pathLengthN = data.getTotalLength();
                        var actived = true;

                        var circleN = g.append("circle")
                            .attr("r", 10)
                            .attr("fill", data.style["stroke"])
                            .attr("transform", getTransform(data))
                            .attr('fill-opacity', 0.5)
                            .classed("train", true)
                            .classed("hiddenLine", function(d) {
                                if (selectedLine == "")
                                    return false;
                                else if (d3.select(data).attr("code_titan") == selectedLine)
                                    return false;
                                else
                                    return true;
                            })
                            .classed("t" + d3.select(data).attr("code_titan"), d3.select(data).attr("code_titan"))
                            .transition()
                            .duration(function() {
                                if (d3.select(data).attr("ligne") == "A")
                                    return durationA / divider;
                                else if (d3.select(data).attr("ligne") == "B")
                                    return durationB / divider;
                                else if (d3.select(data).attr("ligne") == "C")
                                    return durationC / divider;
                                else if (d3.select(data).attr("ligne") == "D")
                                    return durationD / divider;
                                else
                                    return duration;
                            })
                            .ease("linear")
                            .each("end", repeat)
                            .remove()
                            .attrTween("transform", function(d, i) {
                                return function(t) {

                                    var p;

                                    if (d3.select(data).attr("sens") == "Aller")
                                        p = data.getPointAtLength(pathLengthN * t);
                                    else
                                        p = data.getPointAtLength(pathLengthN - pathLengthN * t);

                                    var point = L.point(p.x, p.y);
                                    var coord = map.layerPointToLatLng(point);

                                    var code_titan = d3.select(data).attr("code_titan");
                                    var scale = 1;

                                    if (t == 0 || t == 1)
                                        scale = 0;

                                    for (var key in details_line[code_titan]["stops"]) {

                                        var value = details_line[code_titan]["stops"][key];

                                        var dist = getDistance(value.geo.y, coord.lat, value.geo.x, coord.lng);

                                        if (dist < 50) {
                                            // scale = dist/6;
                                            scale = 2;

                                            var stationsVelo = g.selectAll(".stationsVelo");

                                            for (var s = 0; s < stationsVelo[0].length; s++) {
                                                var node = stationsVelo[0][s];
                                                var point = L.point(node.getPointAtLength(0).x, node.getPointAtLength(0).y);
                                                var c = map.layerPointToLatLng(point);

                                                var d = getDistance(c.lat, coord.lat, c.lng, coord.lng);

                                                if (d < distanceToStation) {
                                                    if (selectedLine == "" || (selectedLine != "" && d3.select(data).attr("code_titan") == selectedLine))
                                                        d3.select(stationsVelo[0][s]).style("stroke-width", "10");
                                                } else {
                                                    d3.select(stationsVelo[0][s]).style("stroke-width", "2");
                                                }
                                            }

                                        }
                                    }

                                    return "translate(" + [p.x, p.y] + ")scale(" + scale + ")";
                                }
                            });

                        //   }
                        // }

                    })();
                });
            }


            console.log("Fin du chargement des données");


            // Reposition the SVG to cover the features.
            function reset(inputPath, collection, feature) {

                var bounds = inputPath.bounds(collection),
                    topLeft = bounds[0],
                    bottomRight = bounds[1];

                svg.attr("width", bottomRight[0] - topLeft[0])
                    .attr("height", bottomRight[1] - topLeft[1])
                    .style("left", topLeft[0] + "px")
                    .style("top", topLeft[1] + "px");

                g.attr("transform", "translate(" + -topLeft[0] + "," + -topLeft[1] + ")");
                feature.attr("d", inputPath);
            }

            function getTransform(node) {
                var p = node.getPointAtLength(0)
                return "translate(" + [p.x, p.y] + ")";
            }

            // Use Leaflet to implement a D3 geometric transformation.
            function projectPoint(x, y) {
                var point = map.latLngToLayerPoint(new L.LatLng(y, x));
                this.stream.point(point.x, point.y);
            }

            function getDistance(lat1, lat2, lon1, lon2) {

                var earthRadius = 6371000; //meters

                var dLat = toRad(lat2 - lat1);
                var dLng = toRad(lon2 - lon1);

                var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                    Math.sin(dLng / 2) * Math.sin(dLng / 2);

                var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

                return earthRadius * c;
            }

            function toRad(Value) {
                return Value * Math.PI / 180;
            }
        </script>
</body>

</html>