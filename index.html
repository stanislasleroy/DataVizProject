<html>
<head>
  <meta charset="utf-8">
  <script src="https://d3js.org/d3.v3.min.js"></script>
  <script src="http://d3js.org/queue.v1.min.js"></script>
   <script src="https://unpkg.com/leaflet@1.0.2/dist/leaflet.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.0.2/dist/leaflet.css" />
  <style>
    body { margin:0;position:fixed;top:0;right:0;bottom:0;left:0; }
  </style>
</head>
<style>
    .province {
        fill: #000;
        stroke: #fff;
        stroke-width: 1px;
    }
    .province:hover {
        fill: #666;
    }
    .hidden {
        display: none;
    }
    div.tooltip {
        color: #222;
        background-color: #fff;
        padding: .5em;
        text-shadow: #f5f5f5 0 1px 0;
        border-radius: 2px;
        opacity: 0.9;
        position: absolute;
    }
    .geojson {
 fill: none;
 stroke: red;
 stroke-width: 5;
}
    #map {
      width: 100%;
      height: 100%;
    }
</style>
<body>
  <div>
  	<input id="slider" type="range" value="1" min="1" max="100" step="1" />
  	<span id="week">week</span>
	</div>
  <div id="map"></div>

  <script>
		//var width = 1200,
  	//	  height = 1000;

    var data;
    var jsonData;

    var max = 0;
    var min = 1000;

// /*
    var map = L.map('map').setView([45.750000, 4.850000], 13);

    L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token={accessToken}', {
      attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="http://mapbox.com">Mapbox</a>',
      maxZoom: 18,
      id: 'stanislasleroy.293gad2b',
      accessToken: 'pk.eyJ1Ijoic3RhbmlzbGFzbGVyb3kiLCJhIjoiY2l3N29ieTFhMDAwbzJ6bzYydmM0cjM4cyJ9.a9t7av6dljaj5TN_FA4XvQ'
    }).addTo(map);


// */
 /*
    var map = new L.Map("map", {center: [45.750000, 4.850000], zoom: 13})
        .addLayer(new L.TileLayer("http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"));
 */




    var svg = d3.select(map.getPanes().overlayPane).append("svg"),
        g = svg.append("g").attr("class", "leaflet-zoom-hide");



    d3.json("ligne_metro.json", function(error, collection) {
      if (error) throw error;

    var transform = d3.geo.transform({point: projectPoint}),
          path = d3.geo.path().projection(transform);
 /*
        var projection = d3.geo.conicConformal()
          .center([4.850000, 45.750000]).scale(800000);

        var path = d3.geo.path()
          .projection(projection);

          svg.selectAll(".geojson").data(collection)
          .enter()
          .append("path")
          .attr("class","geojson")
          .attr("d", path);
 */
       var feature = g.selectAll("path")
           .data(collection.features)
           .enter().append("path")
          .style({'fill': '#B10000', 'fill-opacity': 0.3});

      map.on("viewreset", reset);
      reset();

      // Reposition the SVG to cover the features.
      function reset() {
        var bounds = path.bounds(collection),
            topLeft = bounds[0],
            bottomRight = bounds[1];

        svg .attr("width", bottomRight[0] - topLeft[0])
            .attr("height", bottomRight[1] - topLeft[1])
            .style("left", topLeft[0] + "px")
            .style("top", topLeft[1] + "px");

        g.attr("transform", "translate(" + -topLeft[0] + "," + -topLeft[1] + ")");

        feature.attr("d", path);
      }

      // Use Leaflet to implement a D3 geometric transformation.
      function projectPoint(x, y) {
        var point = map.latLngToLayerPoint(new L.LatLng(y, x));
        this.stream.point(point.x, point.y);
      }
    });





/*
		var svg = d3.select( "body" )
  		.append( "svg" )
		  .attr( "width", width )
		  .attr( "height", height );


    var projection = d3.geo.conicConformal()
    	//.center([2.454071, 46.279229]).scale(10000);
      .center([4.850000, 45.750000]).scale(800000);

    var tooltip = d3.select('body').append('div')
            .attr('class', 'hidden tooltip');

    var carte = svg.append( "carte" );

		var color = d3.scale.quantize()
    			.range(["rgb(254,229,217)",
									"rgb(252,187,161)",
                  "rgb(252,146,114)",
                  "rgb(251,106,74)",
                  "rgb(239,59,44)",
                 	"rgb(203,24,29)",
                  "rgb(153,0,13)"]);

    var path = d3.geo.path()
                 .projection(projection);

    d3.select("#slider").on("input", function() {
			updateViz(+this.value);
		});

    queue()   // permet de charger les fichiers de manière asynchrone
  	//.defer(d3.json, "france-departement.json")
    .defer(d3.json, "stations.json")
  	//.defer(d3.csv, "grippe-2014.csv")
    .defer(d3.csv, "GrippeFrance2003-15.csv")
  	.await(processData);  // une fois les fichiers chargé, la fonction processData
                          // est appelée avec les fichiers en arguments



    function processData(error, francejson, grippedata) {

      	var weeks = [];

     		data = grippedata;
      	jsonData = francejson;

        for (var j = 0; j < grippedata.length; j++) {

          var array = grippedata[j];

          for(var k in array) {
            if(weeks.indexOf(k) == -1
               && k != "region"
               && k != "somme2014") {
              weeks.push(k);
            }
          }
        }

      	//console.log("Number of weeks : " + weeks.length);
      	d3.select('#slider').attr("max", weeks.length)

        for (var i = 0; i < grippedata.length; i++) {

          //Nom de la région
          var dataState = grippedata[i].region;

          //console.log(dataState);

          //Valeur associee à la région
          var dataValue = Object.values(grippedata[i]);

          for(var j = 1; j < dataValue.length - 1; j++) {

            if( dataValue[j] != "region" && dataValue[j] != "somme2014") {

              if(+dataValue[j] < min){
                min = dataValue[j];
              }

              if(+dataValue[j] > max){
                max = dataValue[j];
              }
            }
          }

        	color.domain([min, max]);

          //Recherche de l'etat dans le GeoJSON
          for (var j = 0; j < francejson.features.length; j++) {
            var jsonState = francejson.features[j].properties.nom;
            if (dataState == jsonState) {
              //On injecte la valeur de l'Etat dans le json
              francejson.features[j].properties.value = dataValue;

              //Pas besoin de chercher plus loin
              break;
            }
          }
        }

      updateViz(1);
     }

    function updateViz(value){

    	var weeksArray = Object.keys(data[0]);
     	d3.select('#week').html(weeksArray[value]);

     	drawMap(jsonData, value);
    }

		function drawMap(json, currentWeek) {

      carte = svg.selectAll("path")
        .data(json.features);

      // code en cas de mise a jour de la carte / de changement de semaine
      carte.attr("class", "update")
				.on('mousemove', function(d) {

          var mouse = d3.mouse(svg.node()).map(function(d) {
            return parseInt(d);
          });

          tooltip.classed('hidden', false)
            .attr('style', 'left:' + (mouse[0] + 15) +
                  'px; top:' + (mouse[1] - 35) + 'px')
            .html(d.properties.nom + " : " + d.properties.value[currentWeek]);
        })
        .on('mouseout', function() {
          tooltip.classed('hidden', true);
        })
      	.style("fill", function(d) {
            //on prend la valeur recuperée plus haut
            var value = d.properties.value;

            if (value) {
              console.log("value : " + value[currentWeek]);
              return color(value[currentWeek]);
            } else {
              // si pas de valeur alors en gris
              return "#ccc";
            }
        });

      // code pour la creation de la carte quand les donnees sont chargees la 1e fois.
      carte.enter()
        .append("path")
        .attr("class", "enter")
      	.attr("d", path)
        .on('mousemove', function(d) {

          var mouse = d3.mouse(svg.node()).map(function(d) {
            return parseInt(d);
          });

          tooltip.classed('hidden', false)
            .attr('style', 'left:' + (mouse[0] + 15) +
                  'px; top:' + (mouse[1] - 35) + 'px')
            .html(d.properties.nom + " : " + d.properties.value[currentWeek]);
        })
        .on('mouseout', function() {
          tooltip.classed('hidden', true);
        })
        .style("fill", function(d) {
            //on prend la valeur recupere plus haut
            var value = d.properties.value;

            if (value) {
              return color(value[currentWeek]);
            } else {
              // si pas de valeur alors en gris
              return "#ccc";
            }
        });
    }

    */
  </script>
</body>
</html>
