<html>

<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.7/leaflet.css" />
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="https://d3js.org/d3-queue.v3.min.js"></script>
    <script src="http://cdn.leafletjs.com/leaflet-0.7/leaflet.js">
    </script>
    <style>
        body {
            margin: 0;
            position: fixed;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
        }
        
        #map {
            width: 100%;
            height: 100%;
        }
        
        .hidden {
            display: none;
        }
        
        div.tooltip {
            color: #222;
            background-color: #fff;
            padding: .5em;
            text-shadow: #f5f5f5 0 1px 0;
            border-radius: 2px;
            opacity: 0.9;
            position: absolute;
        }
        
        .hiddenLine {
            display: none;
        }
    </style>
</head>

<body>
    <div>
        <input id="slider" type="range" value="1" min="1" max="100" step="1" />
        <span id="week">heure</span>
    </div>
    <div id="map">

        <!--<div id="map" style="width: 600px; height: 400px"></div>-->

        <script>
            //var map = L.map('map').setView([-41.2858, 174.7868], 13);
            /*
                      mapLink =
                          '<a href="http://openstreetmap.org">OpenStreetMap</a>';
                      L.tileLayer(
                          'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                          attribution: '&copy; ' + mapLink + ' Contributors',
                          maxZoom: 18,
                          }).addTo(map);
                          */
            //var map = new L.Map("map", {center: [45.750000, 4.850000], zoom: 13})
            // .addLayer(new L.TileLayer("http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"));

            var initialZoom = 14;

            // Temps de trajet théorique des différents lignes (ms)
            var durationA = 1260000; // 21 minutes
            var durationB = 1020000; // 17 minutes
            var durationC = 540000; // 9 minutes
            var durationD = 1500000; // 25 minutes
            var duration = 10000;

            // var divider  = 1000;
            var divider = 100;

            // Distance pour prendre en compte les stations Vélov voisine
            // des stations de métro
            var distanceToStation = 200;

            var details_line = {};
            var selectedLine = "";

            var stop_points = {};
            stop_points['type'] = 'FeatureCollection';
            stop_points['features'] = [];

            var total_bike_stations = {};
            var nearby_bike_stations = {};

            var stop_times = {};
            var days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];

            var current_day = "2016-12-20";

            // var map = L.map('map').setView([45.750000, 4.850000], initialZoom);
            var map = L.map('map').setView([45.766000, 4.865000], initialZoom);

            // var map = new L.Map("map", {
            //         center: [45.750000, 4.850000],
            //         zoom: initialZoom
            //     })
            //     .addLayer(new L.TileLayer("http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"));

            L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token={accessToken}', {
                attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="http://mapbox.com">Mapbox</a>',
                maxZoom: 18,
                id: 'stanislasleroy.293gad2b',
                accessToken: 'pk.eyJ1Ijoic3RhbmlzbGFzbGVyb3kiLCJhIjoiY2l3N29ieTFhMDAwbzJ6bzYydmM0cjM4cyJ9.a9t7av6dljaj5TN_FA4XvQ'
            }).addTo(map);

            map.on('click', function(d) {
                // console.log(d);
                var e = d.originalEvent.path[0];
                // console.log(e);

                if (!d3.select(e).attr("class")) {
                    // console.log(d3.select(e).attr("class"));
                    selectedLine = "";
                    d3.selectAll('.train').each(function(d, i) {
                        d3.select(this).classed("hiddenLine", false);
                    });
                }

                // d3.select(this).style("stroke-width", 8);
                // selectedLine = d.properties.code_titan.substring(0, 3);
            })

            // var transform = d3.geo.transform({
            //     point: projectPoint
            // });
            // var path = d3.geo.path().projection(transform);

            var svg = d3.select(map.getPanes().overlayPane).append("svg");
            var g = svg.append("g").attr("class", "leaflet-zoom-hide");

            var tooltip = d3.select('body').append('div')
                .attr('class', 'hidden tooltip');

            // map.on("viewreset", reset);







            d3.queue()
                .defer(d3.json, "tram.json")
                .await(displaySecondaryLine);

            d3.queue()
                .defer(d3.json, "bus.json")
                .await(displaySecondaryLine);

            d3.queue()
                .defer(d3.json, "point_arret.json")
                .defer(d3.json, "ligne_metro.json")
                .defer(d3.json, "stations.json")
                .defer(d3.json, "neptune/301.json")
                .defer(d3.json, "neptune/302.json")
                .defer(d3.json, "neptune/303.json")
                .defer(d3.json, "neptune/304.json")
                .defer(d3.json, "neptune/325.json")
                .defer(d3.json, "neptune/326.json")
                .await(displayPrimaryLine);


            /*
             * Création des lignes secondaires : tram et bus
             */
            function displaySecondaryLine(error, lines) {

                var transform = d3.geo.transform({
                    point: projectPoint
                });
                var path = d3.geo.path().projection(transform);

                var feature = g.selectAll("pathTram")
                    .data(lines.features)
                    .enter().append("path")
                    .style({
                        'fill': '#B10000',
                        'fill-opacity': 0.0
                    })
                    .style({
                        'stroke-width': 1,
                        'stroke': 'red',
                        'stroke-linejoin': 'round',
                        'stroke-linecap': 'round'
                    })
                    .style("stroke", function(d) {
                        var array = d.properties.couleur.split(" ");
                        var color = (d3.rgb(array[0], array[1], array[2])).toString();
                        return color;
                    });

                map.on("viewreset", function() {
                    reset(path, lines, feature);
                });

                reset(path, lines, feature);
            }


            /*
             * Affichage des lignes de métro et des stations
             */
            function displayPrimaryLine(error, stationsMetro, lines, stationsVelo, stopTimes301, stopTimes302, stopTimes303, stopTimes304, stopTimes325, stopTimes326) {

                var transform = d3.geo.transform({
                    point: projectPoint
                });
                var path1 = d3.geo.path().projection(transform);
                var path2 = d3.geo.path().projection(transform);
                var path3 = d3.geo.path().projection(transform);

                total_bike_stations = stationsVelo;

                /*
                 * Affichage des stations Vélo'v
                 */
                var feature1 = g.selectAll("pathVelov")
                    .data(stationsVelo.features)
                    .enter().append("path")
                    .classed("stationsVelo", true)
                    .attr("id", function(d) {
                        return "id_" + d.properties.idstation;
                    })
                    .style("stroke", "black")
                    .style("fill", function(d) {
                        return d.properties.stationbonus === "Oui" ? "#FFBF00" : "#d3d3d3";
                    })
                    .on('mouseover', function(d) {
                        var mouse = d3.mouse(svg.node()).map(function(d) {
                            return parseInt(d);
                        });
                        tooltip.classed('hidden', false)
                            .attr('style', 'left:' + (mouse[0]) + 'px; top:' + (mouse[1]) + 'px')
                            // .html(d.properties.nom + "<br>Id station : " + d.properties.idstation + "<br>Nb de bornes : " + d.properties.nbbornettes + "<br>Station bonus : " + d.properties.stationbonus + "<br><br>Coordonnées : " + d.geometry.coordinates[0] + " " + d.geometry.coordinates[1]);
                            .html(d.properties.nom + "<br>Id station : " + d.properties.idstation + "<br>Nb de bornes : " + d.properties.nbbornettes + "<br>Station bonus : " + d.properties.stationbonus);
                        d3.select(this).style("stroke", "red");
                        // d3.select(this).style("stroke-width", "10");
                    })
                    .on('mouseout', function() {
                        tooltip.classed('hidden', true);
                        d3.select(this).style("stroke", "black");
                        // d3.select(this).style("stroke-width", "2");
                    });


                map.on("viewreset", function() {
                    reset(path1, stationsVelo, feature1);
                });

                reset(path1, stationsVelo, feature1);


                // On ajoute les codes Titan des lignes de métro pour pouvoir récupérer les points d'arrêts des lignes
                for (var i in lines.features) {
                    var id = lines.features[i].properties.code_titan;
                    id = id.substring(0, 3);
                    details_line[id] = {};
                    details_line[id].id = id;
                    details_line[id].color = lines.features[i].properties.couleur;
                }

                // On ajoute les codes Titan des lignes de métro pour pouvoir récupérer les points d'arrêts des lignes
                for (var i in stationsMetro.features) {

                    var id = stationsMetro.features[i].properties.desserte.substring(0, 3);

                    if (details_line[id]) {

                        if (!details_line[id].stops)
                            details_line[id].stops = [];

                        var stop = {};
                        stop.geo = {};
                        stop.geo.x = stationsMetro.features[i].geometry.coordinates[0];
                        stop.geo.y = stationsMetro.features[i].geometry.coordinates[1];
                        details_line[id].stops.push(stop);
                    }
                }

                // /*
                //  * Affichage des stations Métro
                //  */
                // // console.log(JSON.stringify(stationsMetro.features[0]));
                // // console.log(stationsMetro.features[0]);
                // // console.log(stationsMetro.features.length);

                var effective_stop_points;

                effective_stop_points = getEffectiveStopPointsForJSON(stopTimes301);
                loadStopPoints(stopTimes301, effective_stop_points);
                loadStopTimes(stopTimes301, effective_stop_points);

                effective_stop_points = getEffectiveStopPointsForJSON(stopTimes302);
                loadStopPoints(stopTimes302, effective_stop_points);
                loadStopTimes(stopTimes302);

                effective_stop_points = getEffectiveStopPointsForJSON(stopTimes303);
                loadStopPoints(stopTimes303, effective_stop_points);
                loadStopTimes(stopTimes303);

                effective_stop_points = getEffectiveStopPointsForJSON(stopTimes304);
                loadStopPoints(stopTimes304, effective_stop_points);
                loadStopTimes(stopTimes304);

                effective_stop_points = getEffectiveStopPointsForJSON(stopTimes325);
                loadStopPoints(stopTimes325, effective_stop_points);
                loadStopTimes(stopTimes325);

                effective_stop_points = getEffectiveStopPointsForJSON(stopTimes326);
                loadStopPoints(stopTimes326, effective_stop_points);
                loadStopTimes(stopTimes326);


                getNearbyBikeStations();
                // console.log(JSON.stringify(nearby_bike_stations));




                var feature2 = g.selectAll("pathStationsMetro")
                    // .data(stationsMetro.features)
                    .data(stop_points.features)
                    .enter().append("path")
                    // .filter(function(d) { // Filtrer les données pour ne garder que les arrêts des lignes de métro
                    //     console.log(d);
                    //     var id = d.properties.desserte.substring(0, 3);
                    //     if (details_line[id])
                    //         return true;
                    //     else
                    //         return false;
                    // })
                    .classed("stationsMetro", true)
                    .attr("id", function(d) {
                        return d.properties.id;
                    })
                    .style({
                        'stroke-width': 4,
                        'stroke-linejoin': 'round',
                        'stroke-linecap': 'round'
                    })
                    .style("stroke", function(d) {
                        return "gray";
                        var id = d.properties.desserte.substring(0, 3);
                        var array = details_line[id].color.split(" ");
                        var color = (d3.rgb(array[0], array[1], array[2])).toString();
                        return color;
                    })
                    .style("fill", function(d) {
                        return "gray";
                        var id = d.properties.desserte.substring(0, 3);
                        var array = details_line[id].color.split(" ");
                        var color = (d3.rgb(array[0], array[1], array[2])).toString();
                        return color;
                    });

                map.on("viewreset", function() {
                    reset(path2, stop_points, feature2);
                });

                reset(path2, stop_points, feature2);


                /*
                 * Affichage des lignes de Métro
                 */
                var feature3 = g.selectAll("pathMetroLine")
                    .data(lines.features)
                    .enter().append("path")
                    .classed("lineMetro", true)
                    .attr("sens", function(d) {
                        return d.properties.sens;
                    })
                    .attr("ligne", function(d) {
                        return d.properties.ligne;
                    })
                    .attr("code_titan", function(d) {
                        // console.log("Code Titan : " + d.properties.code_titan.substring(0, 3));
                        return d.properties.code_titan.substring(0, 3);
                    })
                    .style({
                        'fill': 'none'
                    })
                    .style({
                        'stroke-width': 4,
                        'stroke-linejoin': 'round',
                        'stroke-linecap': 'round'
                    })
                    .style("stroke", function(d) {
                        var array = d.properties.couleur.split(" ");
                        var color = (d3.rgb(array[0], array[1], array[2])).toString();
                        return color;
                    })
                    .on('mousemove', function(d) {
                        d3.select(this).style("stroke-width", 8);
                    })
                    .on('click', function(d) {
                        d3.select(this).style("stroke-width", 8);
                        selectedLine = d.properties.code_titan.substring(0, 3);
                        console.log(selectedLine);
                        //  console.log(d3.selectAll('.train').filter(".t" + selectedLine));

                        d3.selectAll('.train').each(function(d, i) {
                            d3.select(this).classed("hiddenLine", true);
                        });

                        d3.selectAll('.train').filter(".t" + selectedLine).each(function(d, i) {
                            d3.select(this).classed("hiddenLine", false);
                        });
                    })
                    .on('mouseout', function() {
                        d3.select(this).style("stroke-width", 4);
                    });

                map.on("viewreset", function() {
                    reset(path3, lines, feature3);
                });

                reset(path3, lines, feature3);



                /*
                 * Animation des rames de métro
                 */
                var nodes = d3.selectAll('.lineMetro')[0];

                nodes.forEach(function(data, i) {

                    var nb_stations_rencontrees = 0;

                    var nb_stations = [];

                    var current_line = d3.select(data).attr("code_titan");
                    // console.log(d3.select(data).attr("code_titan"));

                    // nb = 0;

                    // if (d3.select(data).attr("code_titan") == "304" &&
                    // if (d3.select(data).attr("code_titan") == "304") {
                    // d3.select(data).attr("sens") == "Aller" && nb == 0) {
                    // d3.select(data).attr("sens") == "Aller") {
                    // nb++;

                    // var journeys = stop_times[current_line];

                    if (stop_times[current_line]) {

                        // console.log(stop_times[current_line]);
                        var journeys = stop_times[current_line][current_day];

                        var index = 0;

                        var interval = setInterval(function() {

                            if (index >= Object.keys(journeys).length) {
                                // if (index > 0) {
                                clearInterval(interval);
                                console.log("Arrêt des métros");
                            } else {

                                // for (var i = 0; i < Object.keys(journeys).length; i++) {

                                // setTimeout(function() {

                                // console.log(i);

                                //     }
                                // }
                                // var journeys = stop_times[current_line][current_day];
                                // console.log(journeys);
                                // var index = 0;

                                // Object.keys(journeys)[index];




                                // (function repeat() {

                                // if(selectedLine == "") {
                                // console.log(selectedLine);

                                // if(d3.select(data).attr("code_titan") == selectedLine){

                                var pathLengthN = data.getTotalLength();
                                var actived = true;

                                var circleN = g.append("circle")
                                    .attr("r", 8)
                                    .attr("fill", data.style["stroke"])
                                    .attr("transform", getTransform(data))
                                    .attr('fill-opacity', 0.5)
                                    .classed("train", true)
                                    .classed("hiddenLine", function(d) {
                                        if (selectedLine == "")
                                            return false;
                                        else if (d3.select(data).attr("code_titan") == selectedLine)
                                            return false;
                                        else
                                            return true;
                                    })
                                    .classed("t" + d3.select(data).attr("code_titan"), d3.select(data).attr("code_titan"))
                                    .transition()
                                    .duration(function() {
                                        if (d3.select(data).attr("ligne") == "A")
                                            return durationA / divider;
                                        else if (d3.select(data).attr("ligne") == "B")
                                            return durationB / divider;
                                        else if (d3.select(data).attr("ligne") == "C")
                                            return durationC / divider;
                                        else if (d3.select(data).attr("ligne") == "D")
                                            return durationD / divider;
                                        else
                                            return duration;
                                    })
                                    .ease("linear")
                                    // .each("end", repeat)
                                    .remove()
                                    .attrTween("transform", function(d, i) {
                                        return function(t) {

                                            var p;

                                            if (d3.select(data).attr("sens") == "Aller")
                                                p = data.getPointAtLength(pathLengthN * t);
                                            else
                                                p = data.getPointAtLength(pathLengthN - pathLengthN * t);

                                            var coord = map.layerPointToLatLng(L.point(p.x, p.y));

                                            var code_titan = d3.select(data).attr("code_titan");
                                            var scale = 1;

                                            for (var key in details_line[code_titan]["stops"]) {

                                                var value = details_line[code_titan]["stops"][key];

                                                var dist = getDistance(value.geo.y, coord.lat, value.geo.x, coord.lng);

                                                if (dist < 20) {

                                                    scale = 2 - (dist / 40);

                                                    for (var bike_station_id in nearby_bike_stations[code_titan]) {

                                                        var bike_station = nearby_bike_stations[code_titan][bike_station_id];

                                                        var d = getDistance(bike_station.latitude, coord.lat, bike_station.longitude, coord.lng);

                                                        if (d < distanceToStation) {

                                                            if (selectedLine == "" || (selectedLine != "" && d3.select(data).attr("code_titan") == selectedLine))
                                                                d3.select("path#id_" + bike_station_id).style("stroke-width", "5")
                                                                .transition()
                                                                // .delay(1000)
                                                                .duration(500)
                                                                .style("stroke-width", "1");
                                                        }
                                                    }
                                                }
                                            }

                                            return "translate(" + [p.x, p.y] + ")scale(" + scale + ")";
                                        }
                                    });

                                //   }
                                // }

                                // })();
                                // }
                                index++;
                            }
                        }, 2000);
                    }
                    // }
                });
            }


            console.log("Fin du chargement des données");


            // Reposition the SVG to cover the features.

            function reset(_path, _collection, _feature) {

                var bounds = _path.bounds(_collection),
                    topLeft = bounds[0],
                    bottomRight = bounds[1];

                svg.attr("width", bottomRight[0] - topLeft[0])
                    .attr("height", bottomRight[1] - topLeft[1])
                    .style("left", topLeft[0] + "px")
                    .style("top", topLeft[1] + "px");

                g.attr("transform", "translate(" + -topLeft[0] + "," + -topLeft[1] + ")");

                _feature.attr("d", _path);
            }

            function getTransform(node) {
                var p = node.getPointAtLength(0)
                return "translate(" + [p.x, p.y] + ")";
            }

            // Use Leaflet to implement a D3 geometric transformation.
            function projectPoint(x, y) {
                var point = map.latLngToLayerPoint(new L.LatLng(y, x));
                this.stream.point(point.x, point.y);
            }

            function getDistance(lat1, lat2, lon1, lon2) {

                var earthRadius = 6371000; //meters

                var dLat = toRad(lat2 - lat1);
                var dLng = toRad(lon2 - lon1);

                var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                    Math.sin(dLng / 2) * Math.sin(dLng / 2);

                var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

                return earthRadius * c;
            }

            function toRad(Value) {
                return Value * Math.PI / 180;
            }


            /*
             * Renvoie la liste des arrêts pour la ligne "line"
             */
            function getEffectiveStopPointsForJSON(line) {

                result = [];

                var journeyPattern = line.ChouettePTNetwork.ChouetteLineDescription.JourneyPattern;

                for (var i = 0; i < journeyPattern.length; i++) {

                    for (var j = 0; j < journeyPattern[i].stopPointList.length; j++) {

                        if (result.indexOf(journeyPattern[i].stopPointList[j]) === -1) {
                            var value = journeyPattern[i].stopPointList[j];
                            var id = value.substring(value.lastIndexOf(":") + 1);
                            result.push(id);
                        }
                    }
                }
                // console.log(result);
                return result;
            }


            /*
             * Ajoute les points d'arrêts pour la ligne "line" dans l'objet global "stop_points"
             */
            function loadStopPoints(line, effective_stop_points) {

                var current_line = line.ChouettePTNetwork.PTNetwork.lineId.substring(line.ChouettePTNetwork.PTNetwork.lineId.lastIndexOf(":") + 1);
                current_line = current_line.substring(0, 3);


                var points = line.ChouettePTNetwork.ChouetteLineDescription.StopPoint;

                for (var i = 0; i < points.length; i++) {

                    var id = points[i].objectId.substring(points[i].objectId.lastIndexOf(":") + 1);

                    if (effective_stop_points.indexOf(id) !== -1) {

                        var newFeature = {
                            "type": "Feature",
                            "properties": {
                                "id": points[i].objectId,
                                "nom": points[i].name,
                                "desserte": current_line,
                            },
                            "geometry": {
                                "type": "Point",
                                "coordinates": [
                                    parseFloat(points[i].longitude),
                                    parseFloat(points[i].latitude)
                                ]
                            }
                        };

                        stop_points.features.push(newFeature);
                    }
                }

                // console.log(JSON.stringify(stop_points));
            }


            /*
             * Ajoute des horaires d'arrêts pour la ligne "line" dans l'objet global "stop_times"
             */
            function loadStopTimes(line) {

                var current_line = line.ChouettePTNetwork.PTNetwork.lineId.substring(line.ChouettePTNetwork.PTNetwork.lineId.lastIndexOf(":") + 1);
                current_line = current_line.substring(0, 3);

                stop_times[current_line] = {};

                // Création d'un nouveau hash 
                // { VehicleJourneyId -> {vehicleJourneyAtStop -> arrivalTime} }
                var vehicle_journey = getListVehicleJourney(line);


                // Récupération des calendriers
                var timetables = line.ChouettePTNetwork.Timetable;

                for (var i = 0; i < timetables.length; i++) {

                    // Récupération des jours associés à la période de temps
                    var calendar =
                        getCalendars(timetables[i].period.startOfPeriod,
                            timetables[i].period.endOfPeriod,
                            timetables[i].dayType);

                    // Affectation des vehicleJourneyId aux différents jours
                    for (var j = 0; j < calendar.length; j++) {
                        var current_date = calendar[j];
                        stop_times[current_line][current_date] = {};

                        for (var k = 0; k < timetables[i].vehicleJourneyId.length; k++) {
                            stop_times[current_line][current_date][timetables[i].vehicleJourneyId[k]] = vehicle_journey[timetables[i].vehicleJourneyId[k]];
                        }
                    }
                }

                // console.log(JSON.stringify(stop_times));
                // console.log("End");
                // console.log(Object.keys(stop_times[current_line]).length);
            }


            /*
             *
             */
            function getCalendars(periodStart, periodEnd, days_to_compare) {

                var result = [];

                for (var d = new Date(periodStart); d <= new Date(periodEnd); d.setDate(d.getDate() + 1)) {

                    if (Array.isArray(days_to_compare)) {
                        if (days_to_compare.indexOf(days[d.getDay()]) !== -1) {
                            result.push(formatDate(d));
                        }
                    } else {
                        if (days_to_compare === days[d.getDay()]) {
                            result.push(formatDate(d));
                        }
                    }
                }

                return result;
            }


            /*
             * Formatage de la date de la forme YYYY-MM-DD
             */
            function formatDate(date) {
                var d = new Date(date),
                    month = '' + (d.getMonth() + 1),
                    day = '' + d.getDate(),
                    year = d.getFullYear();

                if (month.length < 2) month = '0' + month;
                if (day.length < 2) day = '0' + day;

                return [year, month, day].join('-');
            }


            /*
             *
             */
            function getListVehicleJourney(line) {

                var hash = {};

                // Parcourt des stopTimes pour les affecter aux vehicleJourneyId
                var vehicle_journeys = line.ChouettePTNetwork.ChouetteLineDescription.VehicleJourney;

                for (var i = 0; i < vehicle_journeys.length; i++) {

                    var journey = vehicle_journeys[i];

                    hash[journey.objectId] = {};

                    for (var j = 0; j < journey.vehicleJourneyAtStop.length; j++) {
                        var stop = journey.vehicleJourneyAtStop[j];
                        var id = stop.stopPointId.substring(stop.stopPointId.lastIndexOf(":") + 1);
                        hash[journey.objectId][id] = stop.arrivalTime;
                    }
                }

                return hash;
            }

            /*
             *
             */
            function getExtremitiesOfJourney(line) {

                var hash = {};

                // Parcourt des stopTimes pour les affecter aux vehicleJourneyId
                var vehicle_journeys = line.ChouettePTNetwork.ChouetteLineDescription.VehicleJourney;

                for (var i = 0; i < vehicle_journeys.length; i++) {

                    var journey = vehicle_journeys[i];

                    hash[journey.objectId] = {};

                    for (var j = 0; j < journey.vehicleJourneyAtStop.length; j++) {
                        var stop = journey.vehicleJourneyAtStop[j];
                        var id = stop.stopPointId.substring(stop.stopPointId.lastIndexOf(":") + 1);
                        hash[journey.objectId][id] = stop.arrivalTime;
                    }
                }

                return hash;
            }

            function getNearbyBikeStations() {

                for (var i = 0; i < stop_points.features.length; i++) {

                    var stop_point = stop_points.features[i];

                    for (var j = 0; j < total_bike_stations.features.length; j++) {

                        var bike_station = total_bike_stations.features[j];

                        var d = getDistance(stop_point.geometry.coordinates[1],
                            bike_station.geometry.coordinates[1],
                            stop_point.geometry.coordinates[0],
                            bike_station.geometry.coordinates[0]);

                        if (d < distanceToStation) {

                            if (!nearby_bike_stations[stop_point.properties.desserte])
                                nearby_bike_stations[stop_point.properties.desserte] = {};

                            nearby_bike_stations[stop_point.properties.desserte][bike_station.properties.idstation] = {};
                            nearby_bike_stations[stop_point.properties.desserte][bike_station.properties.idstation].latitude = bike_station.geometry.coordinates[1];
                            nearby_bike_stations[stop_point.properties.desserte][bike_station.properties.idstation].longitude = bike_station.geometry.coordinates[0];
                        }
                    }
                }
            }
        </script>
</body>

</html>