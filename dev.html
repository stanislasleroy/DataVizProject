<html>

<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.7/leaflet.css" />
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="https://d3js.org/d3-queue.v3.min.js"></script>
    <script src="http://cdn.leafletjs.com/leaflet-0.7/leaflet.js">
    </script>
    <style>
        body {
            margin: 0;
            position: fixed;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
        }
        
        #map {
            width: 100%;
            height: 100%;
        }
        
        .hidden {
            display: none;
        }
        
        div.tooltip {
            color: #222;
            background-color: #fff;
            padding: .5em;
            text-shadow: #f5f5f5 0 1px 0;
            border-radius: 2px;
            opacity: 0.9;
            position: absolute;
        }
        
        .hiddenLine {
            display: none;
        }
    </style>
</head>

<body>
    <div>
        <input id="slider" type="range" value="1" min="1" max="100" step="1" />
        <span id="week">heure</span>
    </div>
    <div id="map">

        <!--<div id="map" style="width: 600px; height: 400px"></div>-->

        <script>
            //var map = L.map('map').setView([-41.2858, 174.7868], 13);
            /*
                      mapLink =
                          '<a href="http://openstreetmap.org">OpenStreetMap</a>';
                      L.tileLayer(
                          'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                          attribution: '&copy; ' + mapLink + ' Contributors',
                          maxZoom: 18,
                          }).addTo(map);
                          */
            //var map = new L.Map("map", {center: [45.750000, 4.850000], zoom: 13})
            // .addLayer(new L.TileLayer("http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"));

            var initialZoom = 14;

            // Temps de trajet théorique des différents lignes (ms)
            var durationA = 1260000; // 21 minutes
            var durationB = 1020000; // 17 minutes
            var durationC = 540000; // 9 minutes
            var durationD = 1500000; // 25 minutes
            var duration = 10000;

            // var divider  = 1000;
            var divider = 100;

            // Distance pour prendre en compte les stations Vélov voisine
            // des stations de métro
            var distanceToStation = 200;

            var details_line = {};
            var selectedLine = "";

            var stop_points = {};
            stop_points['type'] = 'FeatureCollection';
            stop_points['features'] = [];

            var stop_times = {};
            var days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];

            var current_day = "2016-12-20";

            // var map = L.map('map').setView([45.750000, 4.850000], initialZoom);
            var map = L.map('map').setView([45.766000, 4.865000], initialZoom);

            L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token={accessToken}', {
                attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="http://mapbox.com">Mapbox</a>',
                maxZoom: 18,
                id: 'stanislasleroy.293gad2b',
                accessToken: 'pk.eyJ1Ijoic3RhbmlzbGFzbGVyb3kiLCJhIjoiY2l3N29ieTFhMDAwbzJ6bzYydmM0cjM4cyJ9.a9t7av6dljaj5TN_FA4XvQ'
            }).addTo(map);

            map.on('click', function(d) {
                // console.log(d);
                var e = d.originalEvent.path[0];
                // console.log(e);

                if (!d3.select(e).attr("class")) {
                    // console.log(d3.select(e).attr("class"));
                    selectedLine = "";
                    d3.selectAll('.train').each(function(d, i) {
                        d3.select(this).classed("hiddenLine", false);
                    });
                }

                // d3.select(this).style("stroke-width", 8);
                // selectedLine = d.properties.code_titan.substring(0, 3);
            })

            var transform = d3.geo.transform({
                point: projectPoint
            });
            var path = d3.geo.path().projection(transform);

            var svg = d3.select(map.getPanes().overlayPane).append("svg");

            var g = svg.append("g").attr("class", "leaflet-zoom-hide");

            var tooltip = d3.select('body').append('div')
                .attr('class', 'hidden tooltip');

            map.on("viewreset", reset);



            // d3.queue()
            //   .defer(d3.json, "tram.json")
            //   .await(displaySecondaryLine);
            //
            // d3.queue()
            //   .defer(d3.json, "bus.json")
            //   .await(displaySecondaryLine);

            d3.queue()
                .defer(d3.json, "point_arret.json")
                .defer(d3.json, "ligne_metro.json")
                .defer(d3.json, "stations.json")
                .defer(d3.json, "neptune/301.json")
                .defer(d3.json, "neptune/302.json")
                .defer(d3.json, "neptune/303.json")
                .defer(d3.json, "neptune/304.json")
                .defer(d3.json, "neptune/325.json")
                .defer(d3.json, "neptune/326.json")
                .await(displayPrimaryLine);


            /*
             * Création des lignes secondaires : tram et bus
             */
            function displaySecondaryLine(error, lines) {

                var feature = g.selectAll("pathTram")
                    .data(lines.features)
                    .enter().append("path")
                    .style({
                        'fill': '#B10000',
                        'fill-opacity': 0.0
                    })
                    .style({
                        'stroke-width': 1,
                        'stroke': 'red',
                        'stroke-linejoin': 'round',
                        'stroke-linecap': 'round'
                    })
                    .style("stroke", function(d) {
                        var array = d.properties.couleur.split(" ");
                        var color = (d3.rgb(array[0], array[1], array[2])).toString();
                        return color;
                    });

                reset(path, lines, feature);
            }


            /*
             * Affichage des lignes de métro et des stations
             */
            function displayPrimaryLine(error, stationsMetro, lines, stationsVelo, stopTimes301, stopTimes302, stopTimes303, stopTimes304, stopTimes325, stopTimes326) {

                /*
                 * Affichage des stations Vélo'v
                 */
                var feature = g.selectAll("pathVelov")
                    .data(stationsVelo.features)
                    .enter().append("path")
                    .classed("stationsVelo", true)
                    .style("stroke", "black")
                    .style("fill", function(d) {
                        return d.properties.stationbonus === "Oui" ? "#FFBF00" : "#d3d3d3";
                    })
                    .on('mouseover', function(d) {
                        var mouse = d3.mouse(svg.node()).map(function(d) {
                            return parseInt(d);
                        });
                        tooltip.classed('hidden', false)
                            .attr('style', 'left:' + (mouse[0]) + 'px; top:' + (mouse[1]) + 'px')
                            .html(d.properties.nom + "<br>Id station : " + d.properties.idstation + "<br>Nb de bornes : " + d.properties.nbbornettes + "<br>Station bonus : " + d.properties.stationbonus);
                        d3.select(this).style("stroke", "red");
                        // d3.select(this).style("stroke-width", "10");
                    })
                    .on('mouseout', function() {
                        tooltip.classed('hidden', true);
                        d3.select(this).style("stroke", "black");
                        // d3.select(this).style("stroke-width", "2");
                    });

                reset(path, stationsVelo, feature);



                // On ajoute les codes Titan des lignes de métro pour pouvoir récupérer les points d'arrêts des lignes
                for (var i in lines.features) {
                    var id = lines.features[i].properties.code_titan;
                    id = id.substring(0, 3);
                    details_line[id] = {};
                    details_line[id].id = id;
                    details_line[id].color = lines.features[i].properties.couleur;
                }

                // On ajoute les codes Titan des lignes de métro pour pouvoir récupérer les points d'arrêts des lignes
                for (var i in stationsMetro.features) {

                    var id = stationsMetro.features[i].properties.desserte.substring(0, 3);

                    if (details_line[id]) {

                        if (!details_line[id].stops)
                            details_line[id].stops = [];

                        var stop = {};
                        stop.geo = {};
                        stop.geo.x = stationsMetro.features[i].geometry.coordinates[0];
                        stop.geo.y = stationsMetro.features[i].geometry.coordinates[1];
                        details_line[id].stops.push(stop);
                    }
                }

                /*
                 * Affichage des stations Métro
                 */
                // console.log(JSON.stringify(stationsMetro.features[0]));
                // console.log(stationsMetro.features[0]);
                // console.log(stationsMetro.features.length);

                var effective_stop_points;

                effective_stop_points = getEffectiveStopPointsForJSON(stopTimes301);
                loadStopPoints(stopTimes301, effective_stop_points);
                loadStopTimes(stopTimes301, effective_stop_points);

                effective_stop_points = getEffectiveStopPointsForJSON(stopTimes302);
                loadStopPoints(stopTimes302, effective_stop_points);
                loadStopTimes(stopTimes302);

                effective_stop_points = getEffectiveStopPointsForJSON(stopTimes303);
                loadStopPoints(stopTimes303, effective_stop_points);
                loadStopTimes(stopTimes303);

                // console.log(JSON.stringify(stop_times));

                effective_stop_points = getEffectiveStopPointsForJSON(stopTimes304);
                loadStopPoints(stopTimes304, effective_stop_points);
                loadStopTimes(stopTimes304);

                effective_stop_points = getEffectiveStopPointsForJSON(stopTimes325);
                loadStopPoints(stopTimes325, effective_stop_points);
                loadStopTimes(stopTimes325);

                effective_stop_points = getEffectiveStopPointsForJSON(stopTimes326);
                loadStopPoints(stopTimes326, effective_stop_points);
                loadStopTimes(stopTimes326);


                var feature = g.selectAll("pathStationsMetro")
                    // .data(stationsMetro.features)
                    .data(stop_points.features)
                    .enter().append("path")
                    // .filter(function(d) { // Filtrer les données pour ne garder que les arrêts des lignes de métro
                    //     console.log(d);
                    //     var id = d.properties.desserte.substring(0, 3);
                    //     if (details_line[id])
                    //         return true;
                    //     else
                    //         return false;
                    // })
                    .classed("stationsMetro", true)
                    .attr("id", function(d) {
                        return d.properties.id;
                    })
                    .style({
                        'stroke-width': 4,
                        'stroke-linejoin': 'round',
                        'stroke-linecap': 'round'
                    })
                    .style("stroke", function(d) {
                        return "gray";
                        var id = d.properties.desserte.substring(0, 3);
                        var array = details_line[id].color.split(" ");
                        var color = (d3.rgb(array[0], array[1], array[2])).toString();
                        return color;
                    })
                    .style("fill", function(d) {
                        return "gray";
                        var id = d.properties.desserte.substring(0, 3);
                        var array = details_line[id].color.split(" ");
                        var color = (d3.rgb(array[0], array[1], array[2])).toString();
                        return color;
                    });

                reset(path, stationsMetro, feature);


                /*
                 * Affichage des lignes de Métro
                 */
                var feature = g.selectAll("pathMetroLine")
                    .data(lines.features)
                    .enter().append("path")
                    .classed("lineMetro", true)
                    .attr("sens", function(d) {
                        return d.properties.sens;
                    })
                    .attr("ligne", function(d) {
                        return d.properties.ligne;
                    })
                    .attr("code_titan", function(d) {
                        console.log("Code Titan : " + d.properties.code_titan.substring(0, 3));
                        return d.properties.code_titan.substring(0, 3);
                    })
                    .style({
                        'fill': 'none'
                    })
                    .style({
                        'stroke-width': 4,
                        'stroke-linejoin': 'round',
                        'stroke-linecap': 'round'
                    })
                    .style("stroke", function(d) {
                        var array = d.properties.couleur.split(" ");
                        var color = (d3.rgb(array[0], array[1], array[2])).toString();
                        return color;
                    })
                    .on('mousemove', function(d) {
                        d3.select(this).style("stroke-width", 8);
                    })
                    .on('click', function(d) {
                        d3.select(this).style("stroke-width", 8);
                        selectedLine = d.properties.code_titan.substring(0, 3);
                        console.log(selectedLine);
                        //  console.log(d3.selectAll('.train').filter(".t" + selectedLine));

                        d3.selectAll('.train').each(function(d, i) {
                            d3.select(this).classed("hiddenLine", true);
                        });

                        d3.selectAll('.train').filter(".t" + selectedLine).each(function(d, i) {
                            d3.select(this).classed("hiddenLine", false);
                        });
                    })
                    .on('mouseout', function() {
                        d3.select(this).style("stroke-width", 4);
                    });

                reset(path, lines, feature);



                /*
                 * Animation des rames de métro
                 */
                var nodes = d3.selectAll('.lineMetro')[0];

                nodes.forEach(function(data, i) {

                    var current_line = d3.select(data).attr("code_titan");
                    console.log(d3.select(data).attr("code_titan"));

                    // var journeys = stop_times[current_line];

                    if (stop_times[current_line]) {

                        // console.log(stop_times[current_line]);
                        var journeys = stop_times[current_line][current_day];

                        var index = 0;

                        var interval = setInterval(function() {

                            if (index >= Object.keys(journeys).length) {
                                clearInterval(x);
                                console.log("Arrêt des métros");
                            }

                            // for (var i = 0; i < Object.keys(journeys).length; i++) {

                            // setTimeout(function() {

                            // console.log(i);

                            //     }
                            // }
                            // var journeys = stop_times[current_line][current_day];
                            // console.log(journeys);
                            // var index = 0;

                            // Object.keys(journeys)[index];




                            // (function repeat() {

                            // if(selectedLine == "") {
                            // console.log(selectedLine);

                            // if(d3.select(data).attr("code_titan") == selectedLine){

                            var pathLengthN = data.getTotalLength();
                            var actived = true;

                            var circleN = g.append("circle")
                                .attr("r", 8)
                                .attr("fill", data.style["stroke"])
                                .attr("transform", getTransform(data))
                                .attr('fill-opacity', 0.5)
                                .classed("train", true)
                                .classed("hiddenLine", function(d) {
                                    if (selectedLine == "")
                                        return false;
                                    else if (d3.select(data).attr("code_titan") == selectedLine)
                                        return false;
                                    else
                                        return true;
                                })
                                .classed("t" + d3.select(data).attr("code_titan"), d3.select(data).attr("code_titan"))
                                .transition()
                                .duration(function() {
                                    if (d3.select(data).attr("ligne") == "A")
                                        return durationA / divider;
                                    else if (d3.select(data).attr("ligne") == "B")
                                        return durationB / divider;
                                    else if (d3.select(data).attr("ligne") == "C")
                                        return durationC / divider;
                                    else if (d3.select(data).attr("ligne") == "D")
                                        return durationD / divider;
                                    else
                                        return duration;
                                })
                                .ease("linear")
                                // .each("end", repeat)
                                .remove()
                                .attrTween("transform", function(d, i) {
                                    return function(t) {

                                        var p;

                                        if (d3.select(data).attr("sens") == "Aller")
                                            p = data.getPointAtLength(pathLengthN * t);
                                        else
                                            p = data.getPointAtLength(pathLengthN - pathLengthN * t);

                                        var coord = map.layerPointToLatLng(L.point(p.x, p.y));

                                        var code_titan = d3.select(data).attr("code_titan");
                                        var scale = 1;

                                        for (var key in details_line[code_titan]["stops"]) {

                                            var value = details_line[code_titan]["stops"][key];

                                            var dist = getDistance(value.geo.y, coord.lat, value.geo.x, coord.lng);

                                            if (dist < 20) {
                                                scale = 2 - (dist / 40);

                                                var stationsVelo = g.selectAll(".stationsVelo");

                                                for (var s = 0; s < stationsVelo[0].length; s++) {

                                                    var node = stationsVelo[0][s];
                                                    var point = L.point(node.getPointAtLength(0).x, node.getPointAtLength(0).y);
                                                    var c = map.layerPointToLatLng(point);

                                                    var d = getDistance(c.lat, coord.lat, c.lng, coord.lng);

                                                    // if (d < distanceToStation) {
                                                    //     if (selectedLine == "" || (selectedLine != "" && d3.select(data).attr("code_titan") == selectedLine))
                                                    //         d3.select(stationsVelo[0][s]).style("stroke-width", "10");
                                                    // } else {
                                                    //     d3.select(stationsVelo[0][s]).style("stroke-width", "2");
                                                    // }
                                                }

                                            }
                                        }

                                        return "translate(" + [p.x, p.y] + ")scale(" + scale + ")";
                                    }
                                });

                            //   }
                            // }

                            // })();
                            // }
                            index++;

                        }, 3000);


                    }



                });
            }


            console.log("Fin du chargement des données");


            // Reposition the SVG to cover the features.
            function reset(inputPath, collection, feature) {

                var bounds = inputPath.bounds(collection),
                    topLeft = bounds[0],
                    bottomRight = bounds[1];

                svg.attr("width", bottomRight[0] - topLeft[0])
                    .attr("height", bottomRight[1] - topLeft[1])
                    .style("left", topLeft[0] + "px")
                    .style("top", topLeft[1] + "px");

                g.attr("transform", "translate(" + -topLeft[0] + "," + -topLeft[1] + ")");
                feature.attr("d", inputPath);
            }

            function getTransform(node) {
                var p = node.getPointAtLength(0)
                return "translate(" + [p.x, p.y] + ")";
            }

            // Use Leaflet to implement a D3 geometric transformation.
            function projectPoint(x, y) {
                var point = map.latLngToLayerPoint(new L.LatLng(y, x));
                this.stream.point(point.x, point.y);
            }

            function getDistance(lat1, lat2, lon1, lon2) {

                var earthRadius = 6371000; //meters

                var dLat = toRad(lat2 - lat1);
                var dLng = toRad(lon2 - lon1);

                var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                    Math.sin(dLng / 2) * Math.sin(dLng / 2);

                var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

                return earthRadius * c;
            }

            function toRad(Value) {
                return Value * Math.PI / 180;
            }


            /*
             *
             */
            function getEffectiveStopPointsForJSON(line) {

                result = [];

                var journeyPattern = line.ChouettePTNetwork.ChouetteLineDescription.JourneyPattern;

                for (var i = 0; i < journeyPattern.length; i++) {

                    for (var j = 0; j < journeyPattern[i].stopPointList.length; j++) {

                        if (result.indexOf(journeyPattern[i].stopPointList[j]) === -1) {
                            var value = journeyPattern[i].stopPointList[j];
                            var id = value.substring(value.lastIndexOf(":") + 1);
                            result.push(id);
                        }
                    }
                }
                // console.log(result);
                return result;
            }

            // function getEffectiveStopPointsForXML(line) {

            //     result = [];

            //     // console.log(line.ChouettePTNetwork.ChouetteLineDescription.JourneyPattern);
            //     console.log(line);
            //     // console.log(line.documentElement);
            //     console.log(line.getElementsByTagName("ChouetteLineDescription")[0].getElementsByTagName("Line")[0].getElementsByTagName("lineEnd"));
            //     var lineEnds = line.getElementsByTagName("ChouetteLineDescription")[0].getElementsByTagName("Line")[0].getElementsByTagName("lineEnd")
            //         // var journeyPattern = line.ChouettePTNetwork.ChouetteLineDescription.JourneyPattern;
            //         // var journeyPattern = line.getElementsByTagName("JourneyPattern");

            //     for (var i = 0; i < lineEnds.length; i++) {
            //         console.log(lineEnds[i].nodeValue);
            //     }


            //     // for (var i = 0; i < journeyPattern.length; i++) {
            //     //     console.log(journeyPattern[i]);
            //     //     for (var j = 0; j < journeyPattern[i].getElementsByTagName("stopPointList.length"); j++) {
            //     //         var item = journeyPattern[i].getElementsByTagName("stopPointList.length")[j];

            //     //         console.log(item);

            //     //         if (result.indexOf(journeyPattern[i].stopPointList[j]) === -1)
            //     //             result.push(journeyPattern[i].stopPointList[j]);
            //     //     }
            //     // }
            //     console.log(result);
            //     return result;
            // }



            /*
             *
             */
            function loadStopPoints(line, effective_stop_points) {

                var points = line.ChouettePTNetwork.ChouetteLineDescription.StopPoint;

                for (var i = 0; i < points.length; i++) {

                    var id = points[i].objectId.substring(points[i].objectId.lastIndexOf(":") + 1);

                    if (effective_stop_points.indexOf(id) !== -1) {

                        // console.log(id);

                        var newFeature = {
                            "type": "Feature",
                            "properties": {
                                "id": points[i].objectId,
                                "nom": points[i].name,
                                "desserte": "TEST",
                            },
                            "geometry": {
                                "type": "Point",
                                "coordinates": [
                                    parseFloat(points[i].longitude),
                                    parseFloat(points[i].latitude)
                                ]
                            }
                        };

                        stop_points.features.push(newFeature);
                    }
                }

                // console.log(JSON.stringify(stop_points));
            }



            function loadStopTimes(line, effective_stop_points) {

                console.log("loadStopTimes");

                var current_line = line.ChouettePTNetwork.PTNetwork.lineId.substring(line.ChouettePTNetwork.PTNetwork.lineId.lastIndexOf(":") + 1);
                current_line = current_line.substring(0, 3);

                stop_times[current_line] = {};
                console.log(current_line);

                // Création d'un nouveau hash 
                // { VehicleJourneyId -> {vehicleJourneyAtStop -> arrivalTime} }
                var vehicle_journey = getListVehicleJourney(line);


                // Récupération des calendriers
                var timetables = line.ChouettePTNetwork.Timetable;

                for (var i = 0; i < timetables.length; i++) {

                    // Récupération des jours associés à la période de temps
                    var calendar =
                        getCalendars(timetables[i].period.startOfPeriod,
                            timetables[i].period.endOfPeriod,
                            timetables[i].dayType);

                    // Affectation des vehicleJourneyId aux différents jours
                    for (var j = 0; j < calendar.length; j++) {
                        var current_date = calendar[j];
                        stop_times[current_line][current_date] = {};

                        for (var k = 0; k < timetables[i].vehicleJourneyId.length; k++) {
                            stop_times[current_line][current_date][timetables[i].vehicleJourneyId[k]] = vehicle_journey[timetables[i].vehicleJourneyId[k]];
                        }

                        // stop_times[current_line][current_date].sort(function(a, b) {
                        //     if (a[Object.keys(a)[0]] < b[Object.keys(b)[0]]) return -1;
                        //     if (a[Object.keys(a)[0]] > b[Object.keys(b)[0]]) return 1;
                        //     return 0;
                        // });
                        // var keysSorted = Object.keys(stop_times[current_line][current_date]).sort(function(a, b) {
                        //     return stop_times[current_line][current_date][a[Object.keys(a)[0]]] - stop_times[current_line][current_date][b[Object.keys(a)[0]]];
                        // })
                    }

                }

                // console.log(JSON.stringify(stop_times));
                // console.log("End");
                // console.log(Object.keys(stop_times[current_line]).length);
            }


            /*
             *
             */
            function getCalendars(periodStart, periodEnd, days_to_compare) {

                var result = [];

                for (var d = new Date(periodStart); d <= new Date(periodEnd); d.setDate(d.getDate() + 1)) {

                    if (Array.isArray(days_to_compare)) {
                        if (days_to_compare.indexOf(days[d.getDay()]) !== -1) {
                            result.push(formatDate(d));
                        }
                    } else {
                        if (days_to_compare === days[d.getDay()]) {
                            result.push(formatDate(d));
                        }
                    }
                }

                return result;
            }


            /*
             * Formatage de la date de la forme YYYY-MM-DD
             */
            function formatDate(date) {
                var d = new Date(date),
                    month = '' + (d.getMonth() + 1),
                    day = '' + d.getDate(),
                    year = d.getFullYear();

                if (month.length < 2) month = '0' + month;
                if (day.length < 2) day = '0' + day;

                return [year, month, day].join('-');
            }


            /*
             *
             */
            function getListVehicleJourney(line) {

                var hash = {};

                // Parcourt des stopTimes pour les affecter aux vehicleJourneyId
                var vehicle_journeys = line.ChouettePTNetwork.ChouetteLineDescription.VehicleJourney;

                for (var i = 0; i < vehicle_journeys.length; i++) {

                    var journey = vehicle_journeys[i];

                    hash[journey.objectId] = {};

                    for (var j = 0; j < journey.vehicleJourneyAtStop.length; j++) {
                        var stop = journey.vehicleJourneyAtStop[j];
                        var id = stop.stopPointId.substring(stop.stopPointId.lastIndexOf(":") + 1);
                        hash[journey.objectId][id] = stop.arrivalTime;
                    }
                }

                return hash;
            }

            /*
             *
             */
            function getExtremitiesOfJourney(line) {

                var hash = {};

                // Parcourt des stopTimes pour les affecter aux vehicleJourneyId
                var vehicle_journeys = line.ChouettePTNetwork.ChouetteLineDescription.VehicleJourney;

                for (var i = 0; i < vehicle_journeys.length; i++) {

                    var journey = vehicle_journeys[i];

                    hash[journey.objectId] = {};

                    for (var j = 0; j < journey.vehicleJourneyAtStop.length; j++) {
                        var stop = journey.vehicleJourneyAtStop[j];
                        var id = stop.stopPointId.substring(stop.stopPointId.lastIndexOf(":") + 1);
                        hash[journey.objectId][id] = stop.arrivalTime;
                    }
                }

                return hash;
            }
        </script>
</body>

</html>